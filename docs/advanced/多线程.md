# 多线程

## 相关概念

### 程序、进程与线程

- **程序**：为完成特定任务，用某种语言编写的*一组指令集合*。
- **进程**：程序的一次执行过程，或是正在内存中运行的应用程序。
  - 每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）
  - 程序是静态的，进程是动态的
  - 进程作为*操作系统调度和分配资源的最小单位*（或者说是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。
- **线程**：进程可进一步细化为线程，是程序内部的*一条执行路径*。一个进程中至少有一个线程。
  - 一个进程同一时间如果*并行*执行多个线程，就是支持多线程的。
  - 线程是CPU调度和执行的最小单位。
  - 一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。
  - 多个线程操作共享的系统资源可能会带来安全的隐患。

### 线程调度

- 分时调度

  所有线程**轮流使用**CPU的使用权，并且平均分配每个线程占用CPU的时间。

- 抢占式调度

​	让优先级高的线程以较大的概率优先使用CPU。如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。

### 并发与并行

- 并行：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个CPU上同时执行。

![image-20251119200233911](https://raw.githubusercontent.com/sunwx625464/images/master/docsify/JavaBasic/image-20251119200233911.png)

- 并发：指两个或多个事件在同一个时间段内发生。即在一段时间内，有多条指令在单个CPU上快速轮换、交替执行，使得在宏观上具有多个进程同时执行的效果。

![image-20251119200244188](https://raw.githubusercontent.com/sunwx625464/images/master/docsify/JavaBasic/image-20251119200244188.png)

### 多线程程序的优点

- 提高应用程序的相应。对图形化界面更有意义，可增强用户体验。
- 提高计算机系统CPU的利用率
- 改善程序结构。将既长有复杂的进程分为多个线程，独立运行，利于理解和修改。

## 创建和启动线程

Java的JVM允许程序运行多个线程，使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。

**Thread类的特性**：

- 每个线程都是通过某个特定的Thread对象的`run()`方法来操作的，因此把`run()`方法体称为**线程执行体**
- 通过该Threa对象的start()方法来启动这个线程，而非直接调用run()
- 要想实现多线程，必须在主线程中创建新的线程对象。

### 创建线程的两种方式

**方式一：继承Thred类**

- 步骤：
  1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。
  2. 创建Thread子类的实例，即创建了线程对象
  3. 调用线程对象的start()方法来启动该线程
- 示例代码：

```java
public class MyThread extends Thread{
    // 定义指定线程名称的构造方法（也可以不写构造方法，这样就是默认调用Thread类的无参构造，默认生成线程名称）
    public MyThread(String name){
        // 调用父类的String参数的构造方法，指定线程名称
        super(name);
    }
    
    // 重写run()方法，完成该线程执行的逻辑
    @Override
    public void run(){
        for(int i = 0; i < 10; i++){
            System.out.println(getName()+":正在执行!" + i);
        }
    }
}

// 测试类
public class TestMyThread{
    public static void main(String[] args){
        // 创建自定义线程对象1
        MyThread mt1 = new MyThread("子线程1");
        // 开启子线程1
        mt1.start();
        
        // 创建自定义线程对象2
        MyThread mt2 = new MyThread("子线程2");
        mt2.start();
        
        // 在主方法中执行for循环
        for(int i = 0; i < 10; i++){
            System.out.println("main线程!"+i);
        }
    }
}
```

> 注意：
>
> 1. 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式
> 2. run()方法由JVM调用，什么时候调用，执行的过程控制都由操作系统的CPU调度决定
> 3. 一个对象只能调用一次start()方法，如果重复调用了，则抛出`IllegalThreadStateException`异常

**方式二：实现Runable接口**

- 步骤：
  1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体是该线程的线程执行体。
  2. 创建Runable实现类的实例，并以此实例作为Thread的target参数来创建Thread对象，该Thread对象才是真正的线程对象。
  3. 调用线程对象的start()方法，启动线程。调用Runnable接口实现类的run方法。
- 示例代码

```java
public class MyRunnable implements Runnable{
    @Override
    public void run(){
        for(int i = 0; i < 20; i++){
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
}

// 测试类
public class TestMyRunnable{
    public static void main(String[] args){
        // 创建自定义类对象 线程任务对象
        MyRunnable mr = new MyRunnable();
        // 创建线程对象
        Thread t = new Thread(mr,"长江");
        t.start();
        for(int i = 0; i < 20; i++){
            System.out.println("黄河 " + i);
        }
    }
}
```

> Runnable 对象仅仅作为 Thread 对象的 target，Runnable 实现类里包含 的 run()方法仅作为线程执行体。 而实际的线程对象依然是 Thread 实例，只是 该 Thread 线程负责执行其 target 的 run()方法。

**两种方法的区别与联系**：

- 联系

  - Thread 类实际上也是实现了 Runnable 接口的类。

  ```java
  public class Thread extends Object implements Runnable
  ```

- 区别
  - 继承 Thread：线程代码存放 Thread 子类 run 方法中。
  - 实现 Runnable：线程代码存在接口的子类的 run 方法。
- 实现 Runnable 接口比继承 Thread 类所具有的优势
  - 避免了单继承的局限性
  - 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。
  - 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。

## 线程常用方法

| 方法名                                | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| public static void sleep(long millis) | 当前线程主动休眠 millis 毫秒。                               |
| public static void yield()            | 当前线程主动放弃时间片，回到就绪状态，竞争下一次时间片。     |
| public final void join()              | 允许其他线程加入到当前线程中。                               |
| public void setPriority(int)          | 线程优先级为1-10，默认为5,优先级越高，表示获取CPU机会越多。  |
| public void setDaemon(boolean)        | 设置为守护线程线程有两类：用户线程（前台线程）、守护线程（后台线程） |

### 线程的优先级

- 通过传递参数给线程的`setPriority()`来设置线程的优先级
- 调整线程的优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。
- 优先级只能反映线程的或者是紧急程度，不能决定是否一定先执行。
- Java线程的优先级使用整数表示，取值范围是1～10，Thread类有以下三个静态常量：
  - static int MAX_PRIORITY：线程可以具有的最高优先级，取值为10
  - static int MIN_PRIORITY：线程可以具有的最低优先级，取值为1
  - static int NORM_PRIORITY：分配给线程的默认优先级，取值为5

```java
public class PriorityThread extends Thread{
	@Override
	public void run() {
		for(int i=0;i<50;i++) {
			System.out.println(Thread.currentThread().getName()+"============"+i);
		}
	}
}
// 测试

public class TestPriority {
	public static void main(String[] args) {
		PriorityThread p1=new PriorityThread();
		p1.setName("p1");
		PriorityThread p2=new PriorityThread();
		p2.setName("p2");
		PriorityThread p3=new PriorityThread();
		p3.setName("p3");
		
		
		p1.setPriority(1);
		p3.setPriority(10);
		
		//启动
		p1.start();
		p2.start();
		p3.start();
	}
}

```

### 线程的休眠

使用线程的`sleep()`可以使线程休眠指定的毫秒数，在休眠结束的时候继续执行线程

```java
class SleepThread extends Thread{
    @Override
    public void run() 
    {
        String[] names = new String[]{"zs","ls","ww","z6"};
        int index = (int)(Math.random()*4);
        for (int i = 3;i > 0;i--)
        {
            System.out.println(i);
            try 
            {
                Thread.sleep(1000);
            } 
            catch (InterruptedException e) 
            {
                e.printStackTrace();
            }
            System.out.println("倒计时："+i);
        }

        System.out.println("抽中学员为:"+names[index]);
    }
}
// 测试
public class TestSleep {
    public static void main(String[] args)
    {
        new SleepThread().start();
    }
}
```

### 线程的让步

- `Thread.yield()`方法作用是暂停当前正在执行的线程对象（及放弃当前拥有的cpu资源），并执行其它线程。
- `yield()`做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其它线程获得运行机会。因此，使用`yield()`的目的是让相同优先级的线程之间能适当的轮转执行。但是，**实际中无法保证** `yield()` **达到让步目的**，因为让步的线程还有可能

```java
class Task1 implements Runnable{
    @Override
    public void run() {
        for (int i = 0;i < 200;i++){
            System.out.println("A:"+i);
        }
    }
}
class Task2 implements Runnable{
    @Override
    public void run() {
        for (int i = 0;i < 10;i++){
            System.out.println("B:"+i);
            Thread.yield();
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        new Thread(new Task2()).start();
        new Thread(new Task1()).start();
    }
}
```

**sleep()和yield()的区别**

- sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程**有可能在进入到可执行状态后马上又被执行**。        
- sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。
- sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。

### 线程的合并

- `Thread`中，`join()`方法的作用是调用线程等待该线程完成后，才能继续往下运行。

![image-20251120141940985](https://raw.githubusercontent.com/sunwx625464/images/master/docsify/JavaBasic/image-20251120141940985.png)

```java
class JoinThread extends Thread{

    public JoinThread(String name){
        super(name);
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始运行");
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()+"-->子线程："+i);
        }
        System.out.println(Thread.currentThread().getName()+"线程结束运行");
    }
}

public class JoinDemo {
    public static void main(String[] args) {
        System.out.println("主线程开始运行。。。");
        JoinThread t1 = new JoinThread("新加入的线程");

        t1.start();

//        try {
//            t1.join();
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

        System.out.println("主线程开始结束。。。");
    }
}

```

## 守护线程

线程有两类：用户线程（前台线程）、守护线程（后台线程）。

守护线程是在后台运行的，它的任务是为其它线程提供服务的，JVM的垃圾回收线程就是典型的守护线程。守护线程的特点是*如果所有非守护线程都死亡，那么守护线程自动死亡*

调用`setDaemon(true)`方法可将指定线程设置为守护线程。必须在线程启动之前设置，调用`isDaemon()`可以判断线程是否是守护线程。

```java
public class DeamonThread extends Thread {
	@Override
	public void run() {
		for(int i=0;i<50;i++) {
			System.out.println(Thread.currentThread().getName()+"----------"+i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}

// 测试
public class TestDeamon {
	public static void main(String[] args) {
		//创建线程(默认前台线程)
		DeamonThread d1=new DeamonThread();
		//设置线程为守护线程
		d1.setDaemon(true);//主线程结束便结束了
		d1.start();
		
		for(int i=0;i<10;i++) {
			System.out.println("主线程:----------"+i);
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
```

## 线程的生命周期

![线程的生命周期.jpg](https://cdn.nlark.com/yuque/0/2021/jpeg/12417724/1624966495988-ee9980e0-118a-4a3c-a0ec-187332d06d3b.jpeg?x-oss-process=image%2Fformat%2Cwebp)

### 五种基本状态

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。

- 新建状态（New）

当线程对象创建后，即进入了新建状态，如：`Thread t = new MyThread();`

- 就绪状态（Runnable）

当调用线程对象的`start()`方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了`t.start()`此线程立即就会执行。

- 运行状态（Running）

当CPU开始调度处于就绪状态的线程时，次时线程才得以真正执行，即进入到运行状态。

> 就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中。

- 阻塞状态（Blocked）

处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，知道其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态可以分为三种：

1. 等待阻塞：运行状态中的线程执行`wait()`方法，使本线程进入到等待阻塞状态
2. 同步阻塞：线程在获取`synchronized`同步锁失败（因为锁被其它线程占用），它会进入同步阻塞状态。
3. 其它阻塞：通过调用线程的`sleep()`或`join()`或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或超时、I/O处理完毕时，线程重新进入就绪状态。

- 死亡状态（Dead）

线程执行完了或者因异常退出了`run()`方法，该线程结束生命周期。

### 多线程状态之间的转换

**就绪状态转换为运行状态**：当此线程得到处理器资源；

**运行状态转换为就绪状态**：当此线程主动调用yield()方法或在运行过程中失去处理器资源。

**运行状态转换为死亡状态**：当此线程线程执行体执行完毕或发生了异常。

此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。

## 线程安全

**为什么会出现线程安全问题？**

- 线程不安全：

  - 当多线程并发访问临界资源时，如果破坏原子操作，可能会造成数据不一致。

  - 临界资源：共享资源（同一对象），一次仅允许一个线程使用，才可保证其正确性。

  - 原子操作：不可分割的多步操作，被视作一个整体，其顺序和步骤不可打乱或缺省。

> 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

```java
class TicketRunnable implements Runnable{

    private int ticket=100;
    //每个窗口卖票的操作
    //窗口 永远开启
    @Override
    public void run() {
        while(true){//有票可以卖
            //出票操作
            
           
            if(ticket>0){
                 //使用sleep模拟一下出票时间 //模拟一下出票的时间
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"正在卖票："+ticket--);
            }
        }
        
    }
}

public class ThreadSafe {
	
	public static void main(String[] args)  throws Exception{
		TicketRunnable t = new TicketRunnable();
        Thread t1 = new Thread(t,"窗口1");
        Thread t2 = new Thread(t,"窗口2");
        Thread t3 = new Thread(t,"窗口3");
        //3个窗口同时卖票
        t1.start();
        t2.start();
        t3.start();
		
	}
}
```

为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。有三种方式完成同步操作：

### 同步代码块

**语法**：

```java
synchronized(临界资源对象){ //对临界资源对象加锁	
//代码（原子操作）
}
```

### 同步锁

对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.

- 锁对象 可以是任意类型。
- 多个线程对象 要使用同一把锁。

```java
package com.qf.sync;

class Ticket2 implements Runnable{

    private int ticket=100;
    Object lock = new Object();
    //每个窗口卖票的操作
    //窗口 永远开启
    @Override
    public void run() {
        while(true){//有票可以卖
            synchronized(lock){//synchronized (this) {//this ---当前对象
                if(ticket>0){
                    //出票操作
                    //使用sleep模拟一下出票时间
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName()+"正在卖票："+ticket--);
                }
            }
        }
    }
}


public class TicketDemo2 {
    public static void main(String[] args) {
        Ticket2 ticket2 = new Ticket2();
        Thread t1 = new Thread(ticket2,"窗口1");
        Thread t2 = new Thread(ticket2,"窗口2");
        Thread t3 = new Thread(ticket2,"窗口3");
        //3个窗口同时卖票
        t1.start();
        t2.start();
        t3.start();
    }
}

```

> 在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。

### 同步方法

使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着

**语法**：

```java
synchronized 返回值类型 方法名称(形参列表){ //对当前对象（this）加锁	
// 代码（原子操作）
}
```

- 只有拥有对象互斥锁标记的线程，才能进入该对象加锁的同步方法中。
- 线程退出同步方法时，会释放相应的互斥锁标记。
- 如果方式是静态，锁是类名.class。

```java
class Ticket3 implements Runnable{

    private int ticket=100;
    //Object lock = new Object();
    //每个窗口卖票的操作
    //窗口 永远开启
    @Override
    public void run() {
        while(true){//有票可以卖
            sellTicket();
            if(ticket<=0){
                break;
            }
        }
    }

    /**
     * 锁对象，谁调用这个方法，就是谁
     * 隐含锁对象，就是this
     *
     * 静态方法，隐含锁对象就是Ticket3.class
     */
    public synchronized  void sellTicket(){
        if(ticket>0){
            //出票操作
            //使用sleep模拟一下出票时间
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+"正在卖票："+ticket--);
        }
    }
}


public class TicketDemo3 {
    public static void main(String[] args) {
        Ticket3 ticket3 = new Ticket3();
        Thread t1 = new Thread(ticket3,"窗口1");
        Thread t2 = new Thread(ticket3,"窗口2");
        Thread t3 = new Thread(ticket3,"窗口3");
        //3个窗口同时卖票
        t1.start();
        t2.start();
        t3.start();
    }
}
```

### Lock

JDK5加入了Lock，与synchronized比较，显示定义，结构更灵活。提供更多实用性方法，功能更强大、性能更优越。

**常用方法**

| 方法名            | 描述                                                |
| ----------------- | --------------------------------------------------- |
| void lock()       | 获取锁，如锁被占用，则等待。                        |
| boolean tryLock() | 尝试获取锁（成功返回true。失败返回false，不阻塞）。 |
| void unlock()     | 释放锁。                                            |

**ReentrantLock**：

Lock接口的实现类，与synchronized一样具有互斥锁功能。

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MyList {
    //创建锁
    private Lock lock = new ReentrantLock();
    private String[] str = {"A","B","","",""};
    private int count = 2;

    public void add(String value){
        //当没有锁的时候，会出现覆盖的情况
        str[count] = value;
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count++;
        System.out.println(Thread.currentThread().getName()+"添加了"+value);
//        lock.lock();
//        try {
//            str[count] = value;
//            try {
//                Thread.sleep(100);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            count++;
//            System.out.println(Thread.currentThread().getName()+"添加了"+value);
//        }finally {
//            lock.unlock();
//        }
    }

    public String[] getStr(){
        return str;
    }
}

// 测试

public class TestMyList {
    public static void main(String[] args) throws InterruptedException {
        MyList myList = new MyList();

        Thread t1 =new Thread(new Runnable() {
            @Override
            public void run() {
                myList.add("hello");
            }
        });
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                myList.add("world");
            }
        });
        t2.start();
        t1.join();
        t2.join();

        String[] str = myList.getStr();
        for (String s : str) {
            System.out.println("s:"+s);
        }
    }
}
```

## 线程通信

### 为什么要处理线程间通信

多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当需要多个线程来共同完成一件任务，并且希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来达到多线程共同操作一份数据。

### 如何保证线程间通信有效利用资源

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— **等待唤醒机制。**

### 等待唤醒机制

**等待唤醒机制**是多个线程间的一种**协作**机制。就是在一个线程进行了规定操作后，就进入等待状态（**wait()**）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（**notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。

#### 线程通信方法

| 方法                                 | 说明                                     |
| ------------------------------------ | ---------------------------------------- |
| public final void wait()             | 释放锁，进入等待队列                     |
| public final void wait(long timeout) | 在超过指定的时间前，释放锁，进入等待队列 |
| public final void notify()           | 随机唤醒、通知一个线程                   |
| public final void notifyAll()        | 唤醒、通知所有线程                       |

1. wait：线程不再活动，不再参与调度，进入 wait set(锁池) 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个**特别的动作**，也即是“**通知（notify）**”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中。wait(long m):wait方法如果在指定的毫秒之后，还没有被notify唤醒，就会自动醒来
   **sleep(long m):不会释放锁**
2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。
3. notifyAll：则释放所通知对象的 wait set 上的全部线程。

> 被通知的线程被唤醒后也不一定能立即恢复执行，因为它当初中断的 地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去 获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。
>
> - 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；
> - 否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态

```java

/*

等待唤醒案例：
1，创建一个顾客线程（消费者）：告知老板要的包子种类和数量，调用wait方法，放弃cpu的执行，进入等待状态
2，创建一个老板线程（生产者）：花了5秒做包子，做好包子之后，调用notify方法，通知顾客吃包子，

注意：
    顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行
    同步使用的锁对象必须是唯一的，
    只有锁对象才能调用wait方法和notify方法


 */
public class Demo1 {
    public static void main(String[] args) {
        //创建锁对象，保证唯一
        Object obj =new Object();

        //创建顾客线程
        new Thread(){
            @Override
            public void run() {
               while(true){
                   //保证等待和唤醒只能有一个在执行
                   synchronized (obj){
                       System.out.println("告知老板要的包子种类和数量");
                       //进入等待
                       try {
                           obj.wait();
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                       }

                       //唤醒之后执行的代码
                       System.out.println("拿到包子，开始吃。。。");
                       System.out.println("---------------------");


                   }
               }
            }
        }.start();

        //创建老板线程
        new Thread(){
            @Override
            public void run() {

               while(true){
                   //花5秒钟做包子，
                   try {
                       Thread.sleep(5000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   //保证等待和唤醒只能有一个在执行
                   synchronized (obj){
                       System.out.println("包子做好了。。。。");
                       //做好包子之后，调用notify方法，通知顾客吃包子，
                       obj.notify();
                   }
               }
            }
        }.start();

    }
}

```

#### 调用 wait 和 notify 需注意的细节

- wait 方法与 notify 方法必须要由同一个锁对象调用。因为：对应的锁对象可以通 过 notify 唤醒使用同一个锁对象调用的 wait 方法后的线程。 
- wait 方法与 notify 方法是属于 Object 类的方法的。因为：锁对象可以是任意对 象，而任意对象的所属类都是继承了 Object 类的。
- wait 方法与 notify 方法必须要在同步代码块或者是同步函数中使用。因为：必须 要通过锁对象调用这 2 个方法。否则会报 java.lang.IllegalMonitorStateException 异 常。

## 死锁

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

![死锁.png](https://cdn.nlark.com/yuque/0/2021/png/12417724/1624968015914-1791c28c-cc88-49be-b228-fa77a665d1f9.png?x-oss-process=image%2Fformat%2Cwebp)

> 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

```java
package com.qf.safe;

public class DeadLockDemo {

    private static Object lock1 = new Object();//锁1，资源1
    private static Object lock2 = new Object();//锁2，资源2


    public static void main(String[] args) {

        //启动一个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized(lock1){
                    System.out.println(Thread.currentThread().getName()+"拿到了锁1，资源1");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"等待锁2，资源2");
                    synchronized (lock2){
                        System.out.println(Thread.currentThread().getName()+"拿到了锁2，资源2");
                    }
                }
            }
        },"线程1").start();



        //产生死锁的线程
//        new Thread(new Runnable() {
//            @Override
//            public void run() {
//                synchronized(lock2){
//                    System.out.println(Thread.currentThread().getName()+"拿到了锁2，资源2");
//                    try {
//                        Thread.sleep(1000);
//                    } catch (InterruptedException e) {
//                        e.printStackTrace();
//                    }
//                    System.out.println(Thread.currentThread().getName()+"等待锁1，资源1");
//                    synchronized (lock1){
//                        System.out.println(Thread.currentThread().getName()+"拿到了锁1，资源1");
//                    }
//                }
//            }
//        },"线程2").start();
    }
}

```

线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过`Thread.sleep(1000);`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。

**破坏死锁**

```java
 //破坏死锁
    new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized(lock1){
                System.out.println(Thread.currentThread().getName()+"拿到了锁1，资源1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"等待锁2，资源2");
                synchronized (lock2){
                    System.out.println(Thread.currentThread().getName()+"拿到了锁2，资源2");
                }
            }
        }
    },"线程2").start();
```

线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。

## Callable接口

- 与使用 Runnable 相比， Callable 功能更强大些
  - 相比 run()方法，可以有返回值
  - 方法可以抛出异常
  - 支持泛型的返回值（需要借助 FutureTask 类，获取返回结果）
- Future 接口
  - 可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完 成、获取结果等。
  - FutureTask 是 Futrue 接口的唯一的实现类
  - FutureTask 同时实现了 Runnable, Future 接口。它既可以作为 Runnable 被 线程执行，又可以作为 Future 得到 Callable 的返回值
- 缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。

```java


import java.util.Random;
import java.util.concurrent.*;


class HandleCallable implements Callable<Integer> {

    private String name;
    public HandleCallable(String name) {
        this.name = name;
    }


    @Override
    public Integer call() throws Exception {
        System.out.println("task"+ name + "开始进行计算");
        Thread.sleep(3000);
        int sum = new Random().nextInt(300);
        int result = 0;
        for (int i = 0; i < sum; i++)
            result += i;
        return result;
    }
}


public class FutureTest{
    public static void main(String[] args) {
        System.out.println("main Thread begin at:"+ System.nanoTime());
        //创建线程池对象
        ExecutorService executor = Executors.newCachedThreadPool();
        HandleCallable task1 = new HandleCallable("1");
        HandleCallable task2 = new HandleCallable("2");
        HandleCallable task3 = new HandleCallable("3");
        //执行
        Future<Integer> result1 = executor.submit(task1);
        Future<Integer> result2 = executor.submit(task2);
        Future<Integer> result3 = executor.submit(task3);
        executor.shutdown();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        //获取到返回的直接
        try {
            System.out.println("task1运行结果:"+result1.get());
            System.out.println("task2运行结果:"+result2.get());
            System.out.println("task3运行结果:"+result3.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        System.out.println("main Thread finish at:"+ System.nanoTime());
    }

}

```

## 线程池

**线程池**：一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

**合理利用线程池能够带来三个好处**：

- 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12417724/1625145161420-59d3c0ff-09b6-4c2d-b28e-06c12a86cd52.png?x-oss-process=image%2Fformat%2Cwebp)

### 核心接口和类

从 JDK5.0 开始，Java 内置线程池相关的 API。在 `java.util.concurrent` 包下提供了线程池相关 API：`ExecutorService`和 `Executors`。

- **ExecutorServic**：是真正的线程池接口，常见子类是`ThreadPoolExecutor`。
  - `void execute(Runnable command)`:执行任务/命令，没有返回值，一般用来执行`Runnable`
  - `<T> Future<T> submit(Callable<T> task)`：执行任务，有返回值，一般用来执行`Callable`
  - `void shutdown()`：关闭连接池
- **Executors**：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。
  - `Executors.newCachedThreadPool()`：创建一个可根据需要创建新线程的线程池
  - `Executors.newFixedThreadPool(int nThreads)` ：创建一个可重用固定线程数的线程池
  - `Executors.newSingleThreadExecutor() `：创建一个只有一个线程的线程池
  - `Executors.newScheduledThreadPool(int corePoolSize)` ：创建 一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

```java
class NumberThread implements Runnable{
    @Override
    public void run(){
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        } 
    }
}

class NumberThread1 implements Runnable{
    @Override
    public void run(){
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}

class NumberThread2 implements Callable{
    @Override
    public Object call() throws Exception{
        int evenSum = 0;//记录偶数的和
        for(int i = 0;i <= 100; i++){
            if(i % 2 == 0){
                evenSum += i;
            }
        }
        return evenSum;
    }
}

public class ThreadPoolTest{
    public static void main(String[] args){
        // 1.提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        // 设置线程池的属性
        service1.setMaximumPoolSize(50); //设置线程池中线程数的上限
        //2.执行指定的线程的操作。需要提供实现 Runnable 接口或 Callable 接 口实现类的对象
        service.execute(new NumberThread());//适合适用于 Runnable 
        service.execute(new NumberThread1());//适合适用于 Runnable
        try { 
            Future future = service.submit(new NumberThread2());//适合 使用于 Callable 
            System.out.println("总和为：" + future.get()); 
        } catch (Exception e) { 
            e.printStackTrace(); 
        }
        //3.关闭连接池 
        service.shutdown();
    }
}
```

















































